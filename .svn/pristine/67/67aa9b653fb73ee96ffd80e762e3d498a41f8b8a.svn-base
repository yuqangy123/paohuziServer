local ruleHelp = {}
local R = {}
local ruleMake = {}

function ruleHelp:setR(r)
	R=r
end

--根据散牌整理出规则牌
function ruleHelp:tidyHandCards(handcards)
	
	table.sort(handcards,function(v1,v2)
		return v1:values() < v2:values()
    end)
	
	
	local ruleCards = {}
	ruleCards[R.rule.Ti_zimo] = {}--提
	ruleCards[R.rule.Kan] = {}--坎
	ruleCards[R.rule.None] = {}
	
	
	--1,4,5,9,9,9,10
	local i = 1
	local handCnt = #handcards
	while(i <= (handCnt-3) )
	do
		local ok = true
		local card = handcards[i]
		local kanIndex = 0
		for j=1, 3 do
			if handcards[i+j].value ~= card.value or handcards[i+j].capital ~= card.capital then
				ok = false
				break
			end
			
			if j == 2 then
				kanIndex = i+j
			end
		end
		
		if ok then
			table.insert(ruleCards[R.rule.Ti_zimo], {handcards[i].id, handcards[i+1].id, handcards[i+2].id, handcards[i+3].id})
			i = i + 3
		elseif kanIndex ~= 0 then
			table.insert(ruleCards[R.rule.Kan], {handcards[kanIndex-2].id, handcards[kanIndex-1].id, handcards[kanIndex-0].id})
			i = i + 2
		else
			i = i + 1
		end
	end	
	if handcards[handCnt-2]:equal(handcards[handCnt-1]) and handcards[handCnt-1]:equal(handcards[handCnt-0]) then
		table.insert(ruleCards[R.rule.Kan], {handcards[handCnt-2].id, handcards[handCnt-1].id, handcards[handCnt-0].id})
	end
	
	local tmpCards = {}
	for i=1, handCnt do
		local r = false
		for k,v in pairs(ruleCards[R.rule.Ti_zimo]) do
			for kk,vv in pairs(v) do
				if handcards[i].id == vv then 
					r = true 
					break 
				end
			end
			if r then
				break
			end
		end
		if not r then
			for k,v in pairs(ruleCards[R.rule.Kan]) do
				for kk,vv in pairs(v) do
					if handcards[i].id == vv then 
						r = true 
						break 
					end
				end
				if r then
					break
				end
			end
		end
		if not r then
			ruleCards[R.rule.None][#ruleCards[R.rule.None]+1] = handcards[i].id
		end
	end
	
	
	
	return ruleCards
end



function ruleMake:findChi(ids, cards, card)
	local tmpCards = {}
	local valueList = {}
	local res = {}
	local findId = card
	if #cards < 3 then
		return res
	end
	
	for k,v in pairs(cards) do
		if not tmpCards[ids[v].value] then tmpCards[ids[v].value] = {} valueList[#valueList+1]=ids[v].value end
		table.insert(tmpCards[ids[v].value], ids[v])
	end
	if findId then
		if not tmpCards[ids[findId].value] then  tmpCards[ids[findId].value] = {} valueList[#valueList+1]=ids[findId].value end
		table.insert(tmpCards[ids[findId].value], ids[findId])
	end
	
	table.sort(valueList, function(a,b)return a<b end)
	
	for i=1,#valueList do
		local clist = tmpCards[valueList[i]]
		if #clist >= 3 then
			for j=1, #clist-2 do
				for k=j+1, #clist-1 do
					for n=k+1, #clist do
						if clist[j].capital ~= clist[k].capital or clist[j].capital ~= clist[n].capital then
							table.insert(res, {clist[j].id, clist[k].id, clist[n].id})
						end
					end
				end
			end
		end
		
		local a = tmpCards[valueList[i]+0]
		local b = tmpCards[valueList[i]+1]
		local c = tmpCards[valueList[i]+2]
		local fcap = nil
		if b and c then
			for k,v in pairs(a) do
				fcap = v.capital
				local bcard = nil
				for bk,bv in pairs(b) do
					if fcap == bv.capital then
						bcard = bv
						for ck,cv in pairs(c) do
							if fcap == cv.capital then
								ccard = cv
								table.insert(res, {v.id, bcard.id, ccard.id})
							end
						end
					end
				end
				
			end
		end
	end
	
	if tmpCards[R.value.v2] and tmpCards[R.value.v7] and tmpCards[R.value.v10] then
		for k,v in pairs(tmpCards[R.value.v2]) do
			local cap = v.capital
			local bcard = nil
			for k7,v7 in pairs(tmpCards[R.value.v7]) do
				if v7.capital == cap then
					bcard = v7
					break
				end
			end
			local ccard = nil
			for k10,v10 in pairs(tmpCards[R.value.v10]) do
				if v10.capital == cap then
					ccard = v10
					break
				end
			end
			if bcard and ccard then
				table.insert(res, {v.id, bcard.id, ccard.id})
			end
		end
	end
	
	--移除跟findId不相关的
	local pos = 0
	while findId and true do
		pos = pos + 1
		if pos > #res then 
			break
		end
		if res[pos][1] ~= findId and res[pos][2] ~= findId and res[pos][3] ~= findId then
			table.remove(res, pos)
			pos = 0
		end
	end
	
	--移除重复的组合
	table.sort(res, function(a,b) return ids[a[1]].value < ids[b[1]].value end)
	pos = 0
	while true do
		pos = pos + 1
		if pos > #res-1 then break end
		
		if ids[res[pos][1]]:equal(ids[res[pos+1][1]]) and 
			ids[res[pos][2]]:equal(ids[res[pos+1][2]]) and
				ids[res[pos][3]]:equal(ids[res[pos+1][3]]) then
			table.remove(res, pos)
			pos = 0
		end
	end
	
	return res	
end

function ruleMake:Chi(ids, cards, card)
	local function filtercard(findcardlist, fcards)
		if #findcardlist == 1 then
			for k,v in pairs(fcards) do if v == findcardlist[1] then table.remove(fcards, k) break end end
			local mrule = ruleMake:findChi(ids, fcards, findcardlist[1])
			return mrule
		end
		
		local res = {}
		for i=1, #findcardlist do
			for k,v in pairs(fcards) do if v == findcardlist[i] then table.remove(fcards, k) break end end
			local mrule = ruleMake:findChi(ids, fcards, findcardlist[i])
			
			
			for k,v in pairs(mrule) do
				local subfcards = {}
				local subfindcardlist = {}
				for ii=i+1, #findcardlist do 
					subfindcardlist[#subfindcardlist+1]=findcardlist[ii]
				end
				for ii=1, #fcards do
					if fcards[ii] ~= v[1] and fcards[ii] ~= v[2] and fcards[ii] ~= v[3] and fcards[ii] ~= v[3] then
						subfcards[#subfcards+1]=fcards[ii]
					end
				end
				
				local continue = true
				for kk,vv in pairs(subfindcardlist) do
					if vv == v[1] or vv == v[2] or vv == v[3] then
						continue = false
						break
					end
				end
				if continue then 
					local subres = filtercard(subfindcardlist, subfcards)				
					for si=1, #subres do
						--if #subres[si] == math.max(3, (#findcardlist-1)*3) then
							
							
							res[#res+1] = {v[1], v[2], v[3]}
							for sj=1, #subres[si] do
								table.insert(res[#res], subres[si][sj])
							end
						--end
					end
				end
			end
			fcards[#fcards+1] = findcardlist[i]
		end
		
		return res
	end
	
	local ecardList = {}
	for k,v in pairs(cards) do
		if ids[v]:equal(ids[card]) then
			ecardList[#ecardList+1] = v
		end
	end
	ecardList[#ecardList+1] = card
	cards[#cards+1] = card
	
	local ecardcnt = #ecardList * 3
	local res = filtercard(ecardList, cards)
	
	
	local i = #res
	while true do
		if i < 1 then break end
		if #res[i] ~= ecardcnt then
			table.remove(res, i)
			i = #res
		else
			i=i-1
		end
	end
	
	i = #res
	local j = 1
	while true do
		if i == j then break end
		if #res < 2 or i < 2 then
			i = #res
			j = j + 1
			if j >= i then
				break
			end
		end
		
		local ca = 0
		local cb = 0
		for k,v in pairs(res[j]) do ca = ca + ids[v]:values()  end
		for k,v in pairs(res[i]) do cb = cb + ids[v]:values()  end
		
		if ca ~= 0 and ca == cb then
			table.remove(res, i)
			i=#res
		else
			i=i-1
		end
	end
	return res
end

function ruleMake:Peng(ids, cards, card)
	local tmpCards = {}
	local res = {}
	local keyId = card
	
	for k,v in pairs(cards) do table.insert(tmpCards, ids[v]) end
	table.insert(tmpCards, ids[keyId])
	
	table.sort(tmpCards,function(v1,v2)
		return v1:values() < v2:values()
    end)
	
	local pos = 1
	while pos <= (#tmpCards-2) do
        if tmpCards[pos].value == tmpCards[pos+1].value and tmpCards[pos].value == tmpCards[pos+2].value then
			if tmpCards[pos].capital == tmpCards[pos+1].capital and tmpCards[pos].capital == tmpCards[pos+2].capital then
				table.insert(res, {tmpCards[pos].id, tmpCards[pos+1].id, tmpCards[pos+2].id})
			end
		end
        pos = pos + 1
    end
	
	pos = 0
	while true do
		pos = pos + 1
		if pos > #res then 
			break
		end
		if res[pos][1] ~= keyId and res[pos][2] ~= keyId and res[pos][3] ~= keyId then
			table.remove(res, pos)
			pos = 0
		end
	end
	return res
end

function ruleMake:TiPao(ids, cards, card)
	local res = {}
	
	for k,v in pairs(cards) do
		if ids[v[1]]:equal(ids[card]) and ids[v[2]]:equal(ids[card]) and ids[v[3]]:equal(ids[card]) then
			table.insert(res, {v[1], v[2], v[3], card})
		end
	end
	
	return res
end


function ruleHelp:getHupaiType(cardMgr, ids, isZhuang)
	local res = {}
	local handcards = {}
	for k,v in pairs(cardMgr.handed[R.rule.None]) do 
		table.insert(handcards, ids[v]) 
	end
	table.sort(handcards, function (v1,v2) return v1:values() < v2:values() end)
	
	--五福
	local cardthree = 0
	local historyCnt = 0
	for k,v in pairs(cardMgr.history) do
		historyCnt = historyCnt + 1
		if k == R.rule.Wei or k == R.rule.Wei_chou or k == R.rule.Peng then
			cardthree = cardthree + #cardMgr.showed[k]
		end
	end
	if cardthree == 5 then
		return R.wintype.wufu
	end

	--四清跑双
	if cardthree == 4 and ruleHelp:noneSingle(handcards) then
		return R.wintype.paoshuang
	end
	
	--七对
	local cardtwo = 0
	local noneCards = cardMgr.handed[R.rule.None]
	if #noneCards >= 14 then
		local i = 1
		while i <= #noneCards-1 do
			if ids[noneCards[i]]:equal(ids[noneCards[i+1]]) then
				cardtwo = cardtwo + 1
				i = i + 2
			else
				i = i + 1
			end
		end
		
		if cardtwo >= 7 then
			return R.wintype.qidui
		end
	end
	
	--双龙
	if cardMgr.showed[R.rule.Ti_zimo] and #cardMgr.showed[R.rule.Ti_zimo] >= 2 then
		return R.wintype.shuanglong
	end
	if cardMgr.showed[R.rule.Ti_kan] and #cardMgr.showed[R.rule.Ti_kan] >= 2 then
		return R.wintype.shuanglong
	end
	if cardMgr.showed[R.rule.Ti_wei] and #cardMgr.showed[R.rule.Ti_wei] >= 2 then
		return R.wintype.shuanglong
	end
	
	
	--平胡
	if ruleHelp:noneSingle(handcards) then
		return R.wintype.pinghu
	end
	
	return R.wintype.none
end



function ruleHelp:noneSingle(cards, haveYidui)
	local cardcnt = #cards
	if cardcnt == 0 then return true  end
	if cardcnt == 1 then return false  end
	
	local remains = {}
	local idx=1
	local acard = cards[idx]
	local bcard = {value=acard.value+1, capital=acard.capital, id=0}
	local ccard = {value=acard.value+2, capital=acard.capital, id=0}
	idx=2
	while( idx <= cardcnt ) do--顺序吃，组合成员固定
		if bcard.id == 0 then
			if cards[idx].value == bcard.value and cards[idx].capital == bcard.capital then
				bcard.id = cards[idx].id
			else
				remains[#remains+1]=cards[idx]
			end			
		elseif ccard.id == 0 then
			if cards[idx].value == ccard.value and cards[idx].capital == ccard.capital then
				ccard.id = cards[idx].id
				break
			else
				remains[#remains+1]=cards[idx]
			end
		end
		idx=idx+1
	end
	if bcard.id > 0 and ccard.id > 0 then
		for i=idx+1,cardcnt do remains[#remains+1]=cards[i] end
		if ruleHelp:noneSingle(remains, haveYidui) then return true end
	end
	
	local keyvalue = R.value.v2
	if acard.value == R.value.v2 then--2710，组合成员固定
		idx=2
		local keycapital = acard.capital
		keyvalue = R.value.v7
		remains = {}
		while( idx <= cardcnt ) do
			if keycapital == cards[idx].capital and keyvalue == cards[idx].value then
				if keyvalue == R.value.v7 then
					keyvalue = R.value.v10
				elseif keyvalue == R.value.v10 then
					keyvalue = nil
					break
				end
			else
				remains[#remains+1]=cards[idx]
			end
			idx=idx+1
		end
	end
	if not keyvalue then
		for i=idx+1,cardcnt do remains[#remains+1]=cards[i] end
		if ruleHelp:noneSingle(remains, haveYidui) then return true end
	end
	
	idx=1
	acard = cards[idx]
	idx=2
	local vlist = {}
	remains = {}
	while( idx <= cardcnt and cards[idx].value == acard.value ) do--大小三搭，组合成员bu固定，例如d1d1s1,d1s1s1，碰也可以一起检测
		vlist[#vlist+1] = cards[idx]
		idx = idx + 1
	end
	for i=idx,cardcnt do remains[#remains+1]=cards[i] end	
	for i=1, #vlist do
		for j=i+1, #vlist do
			for k=1, #vlist do
				if k ~= i and k ~= j then
					remains[#remains+1]=cards[k]
				end
			end
			if ruleHelp:noneSingle(remains, haveYidui) then
				return true
			else
				remains[#remains]=nil
				remains[#remains]=nil
			end
		end
	end
	
	if cards[1].value == cards[2].value and cards[1].capital == cards[2].capital then--唯一一对
		remains = {}
		for i=3,cardcnt do remains[#remains+1]=cards[i] end
		if not haveYidui then
			haveYidui = true
			if ruleHelp:noneSingle(remains, haveYidui) then return true end
		end
	end
end
--[[
function ruleHelp:testHupai(handed, ids, payCard)
	local headCards = {}
	
	for k,v in pairs(handed) do
		table.insert(headCards, ids[v])
	end
	if payCard then table.insert(headCards, ids[payCard]) end
		
	table.sort(headCards, function (v1, v2)
		return v1:values() < v2:values()
	end)
	
	return ruleHelp:noneSingle(headCards)
end
--]]

--增加一张addcard牌，放到cards里面，能否产出rule的规则牌
function ruleHelp:makeRulesCard(rule, ids, cards, addcard)
	if R.rule.Chi == rule then
		return ruleMake:Chi(ids, cards, addcard)
		
	elseif R.rule.Peng == rule then
		return ruleMake:Peng(ids, cards, addcard)
		
	elseif R.rule.Wei == rule then
		return ruleMake:Peng(ids, cards, addcard)
		
	elseif R.rule.Ti == rule or R.rule.Pao == rule then
		return ruleMake:TiPao(ids, cards, addcard)

	--elseif R.rule.Hupai == rule then
		--return ruleMake:Hupai(ids, cardMgr, addcard)
		
	end
	
	return {}
end

function ruleMake:Chi_test(ids, cards)
	local res = ruleMake:findChi(ids, cards)
	return #res > 0
end

function ruleMake:Peng_test(ids, cards)
	local tmpCards = {}
	
	if #cards ~= 3 then
		return false
	end
		
	for k,v in pairs(cards) do table.insert(tmpCards, ids[v]) end
	table.sort(tmpCards,function(v1,v2)
			return v1:values() < v2:values()
		end)
	
	if tmpCards[1].value == tmpCards[2].value and tmpCards[1].value == tmpCards[3].value then
		if tmpCards[1].capital == tmpCards[2].capital and tmpCards[1].capital == tmpCards[3].capital then
			return true
		end
	end
end

function ruleMake:TiPao_test(ids, cards)
	local tmpCards = {}
	local res = {}
	
	for k,v in pairs(cards) do table.insert(tmpCards, ids[v]) end
	table.sort(tmpCards,function(v1,v2)
			return v1:values() < v2:values()
		end)
	
	
	if #cards == 4 then
		if tmpCards[1].value == tmpCards[2].value and tmpCards[1].value == tmpCards[3].value and tmpCards[1].value == tmpCards[4].value then
			if tmpCards[1].capital == tmpCards[2].capital and tmpCards[1].capital == tmpCards[3].capital and tmpCards[1].capital == tmpCards[4].capital then
				return true
			end
		end
	end
end

function ruleHelp:testRulesCard(rule, ids, cards)
	
	if R.rule.Chi == rule then
		return ruleMake:Chi_test(ids, cards)
		
	elseif R.rule.Peng == rule or R.rule.Wei == rule or R.rule.Kan == rule then
		return ruleMake:Peng_test(ids, cards)
		
	elseif R.rule.Ti == rule or R.rule.Pao == rule then
		return ruleMake:TiPao_test(ids, cards, card)

	end
	
end

function ruleHelp:isForceRule1(rule)
	return 	rule == R.rule.Ti or 
			rule == R.rule.Ti_zimo or
			rule == R.rule.Ti_kan or
			rule == R.rule.Ti_wei or
			rule == R.rule.Kan or
			rule == R.rule.Wei
end
function ruleHelp:isForceRule2(rule)
	return 	rule == R.rule.Pao or 
			rule == R.rule.Pao_kan or 
			rule == R.rule.Pao_wei or 
			rule == R.rule.Pao_peng
end

function ruleHelp:compareRuleLevel(r1, r2)
	return tonumber(r1) > tonumber(r2)
end

--是否需要显示系统发的牌
function ruleHelp:hideSystemCard(rule)
	return rule == R.rule.Ti_zimo or
			rule == R.rule.Wei or
			rule == R.rule.Wei_chou
end

function ruleHelp:checkWufuBaojing(history, hands, ids)
	local threeCnt = 0
	for k,v in pairs(history) do
		if v.payrule == R.rule.Wei or v.payrule == R.rule.Peng then
			threeCnt = threeCnt + 1
		end
	end
	
	return threeCnt == 4 and #hands == 2 and ids[hands[1]]:equal(ids[hands[2]])
end

return ruleHelp
