local ruleHelp = {}
local R = {}
local ruleMake = {}

function ruleHelp:setR(r)
	R=r
end

--根据散牌整理出规则牌
function ruleHelp:tidyHandCards(handcards)
	
	table.sort(handcards,function(v1,v2)
		return v1:values() < v2:values()
    end)
	
	
	local ruleCards = {}
	ruleCards[R.rule.Ti_zimo] = {}--提
	ruleCards[R.rule.Kan] = {}--坎
	ruleCards[R.rule.None] = {}
	
	
	--1,4,5,9,9,9,10
	local i = 1
	local handCnt = #handcards
	while(i <= (handCnt-3) )
	do
		local ok = true
		local card = handcards[i]
		local kanIndex = 0
		for j=1, 3 do
			if handcards[i+j].value ~= card.value or handcards[i+j].capital ~= card.capital then
				ok = false
				break
			end
			
			if j == 2 then
				kanIndex = i+j
			end
		end
		
		if ok then
			table.insert(ruleCards[R.rule.Ti_zimo], {handcards[i].id, handcards[i+1].id, handcards[i+2].id, handcards[i+3].id})
			i = i + 3
		elseif kanIndex ~= 0 then
			table.insert(ruleCards[R.rule.Kan], {handcards[kanIndex-2].id, handcards[kanIndex-1].id, handcards[kanIndex-0].id})
			i = i + 2
		else
			i = i + 1
		end
	end	
	if handcards[handCnt-2]:equal(handcards[handCnt-1]) and handcards[handCnt-1]:equal(handcards[handCnt-0]) then
		table.insert(ruleCards[R.rule.Kan], {handcards[handCnt-2].id, handcards[handCnt-1].id, handcards[handCnt-0].id})
	end
	
	local tmpCards = {}
	for i=1, handCnt do
		local r = false
		for k,v in pairs(ruleCards[R.rule.Ti_zimo]) do
			for kk,vv in pairs(v) do
				if handcards[i].id == vv then 
					r = true 
					break 
				end
			end
			if r then
				break
			end
		end
		if not r then
			for k,v in pairs(ruleCards[R.rule.Kan]) do
				for kk,vv in pairs(v) do
					if handcards[i].id == vv then 
						r = true 
						break 
					end
				end
				if r then
					break
				end
			end
		end
		if not r then
			ruleCards[R.rule.None][#ruleCards[R.rule.None]+1] = handcards[i].id
		end
	end
	
	
	
	return ruleCards
end



function ruleMake:Chi(ids, cards, card)
	local tmpCards = {}
	local valueList = {}
	local res = {}
	local keyId = card
	if #cards < 3 then
		return false
	end
	
	for k,v in pairs(cards) do
		if not tmpCards[ids[v].value] then tmpCards[ids[v].value] = {} valueList[#valueList+1]=ids[v].value end
		table.insert(tmpCards[ids[v].value], ids[v])
	end
	if not tmpCards[ids[keyId].value] then  tmpCards[ids[keyId].value] = {} valueList[#valueList+1]=ids[v].value end
	table.insert(tmpCards[ids[keyId].value], ids[keyId])
		
	table.sort(valueList, function(a,b)return a<b end)
	
	for i=1,#valueList-2 do
		local clist = tmpCards[valueList[i]]
		if #clist >= 3 then			
			for j=1, #clist-2 do
				if clist[j].capital ~= clist[j+1].capital or clist[j].capital ~= clist[j+2].capital then
					table.insert(res, {clist[j].id, clist[j+1].id, clist[j+2].id})
				end
			end
		end
		
		local a = tmpCards[valueList[i]+0]
		local b = tmpCards[valueList[i]+1]
		local c = tmpCards[valueList[i]+2]
		local fcap = nil
		if b and c then
			for k,v in pairs(a) do
				fcap = v.capital
				local bcard = nil
				for bk,bv in pairs(b) do
					if fcap == bv.capital then
						bcard = bv
						break
					end
				end
				local ccard = nil
				for ck,cv in pairs(c) do
					if fcap == cv.capital then
						ccard = cv
						break
					end
				end
				if bcard and ccard then
					table.insert(res, {v.id, bcard.id, ccard.id})
				end
			end
		end
	end
	
	if tmpCards[R.value.v2] and tmpCards[R.value.v7] and tmpCards[R.value.v10] then
		for k,v in pairs(tmpCards[R.value.v2]) do
			local cap = v.capital
			local bcard = nil
			for k7,v7 in pairs(tmpCards[R.value.v7]) do
				if v7.capital == cap then
					bcard = v7
					break
				end
			end
			local ccard = nil
			for k10,v10 in pairs(tmpCards[R.value.v10]) do
				if v10.capital == cap then
					ccard = v10
					break
				end
			end
			if bcard and ccard then
				table.insert(res, {v.id, bcard.id, ccard.id})
			end
		end
	end
	local pos = 0
	while true do
		pos = pos + 1
		if pos > #res then 
			break
		end
		if res[pos][1] ~= keyId and res[pos][2] ~= keyId and res[pos][3] ~= keyId then
			table.remove(res, pos)
			pos = 0
		end
	end
	
	--移除重复的组合
	table.sort(res, function(a,b) ids[a[1]].value < ids[b[1]].value end)
	pos = 0
	while true do
		pos = pos + 1
		if pos > #res-1 then break end
		
		if ids[res[pos][1]]:equal(ids[res[pos+1][1]]) and 
			ids[res[pos][2]]:equal(ids[res[pos+1][2]]) and
				ids[res[pos][3]]:equal(ids[res[pos+1][3]]) then
			table.remove(res, pos)
			pos = 0
		end
	end
	
	return res
	
	
end

function ruleMake:Peng(ids, cards, card)
	local tmpCards = {}
	local res = {}
	local keyId = card
	
	for k,v in pairs(cards) do table.insert(tmpCards, ids[v]) end
	table.insert(tmpCards, ids[keyId])
	
	table.sort(tmpCards,function(v1,v2)
		return v1:values() < v2:values()
    end)
	
	local pos = 1
	while pos <= (#tmpCards-2) do
        if tmpCards[pos].value == tmpCards[pos+1].value and tmpCards[pos].value == tmpCards[pos+2].value then
			if tmpCards[pos].capital == tmpCards[pos+1].capital and tmpCards[pos].capital == tmpCards[pos+2].capital then
				table.insert(res, {tmpCards[pos].id, tmpCards[pos+1].id, tmpCards[pos+2].id})
			end
		end
        pos = pos + 1
    end
	
	pos = 0
	while true do
		pos = pos + 1
		if pos > #res then 
			break
		end
		if res[pos][1] ~= keyId and res[pos][2] ~= keyId and res[pos][3] ~= keyId then
			table.remove(res, pos)
			pos = 0
		end
	end
	return res
end

function ruleMake:TiPao(ids, cards, card)
	local res = {}
	
	for k,v in pairs(cards) do
		if ids[v[1]]:equal(ids[card]) and ids[v[2]]:equal(ids[card]) and ids[v[3]]:equal(ids[card]) then
			table.insert(res, {v[1], v[2], v[3], card})
		end
	end
	
	return res
end


function ruleHelp:getHupaiType(cardMgr, ids, isZhuang)
	local res = {}
	local handcards = {}
	for k,v in pairs(cardMgr.handed[R.rule.None]) do 
		table.insert(handcards, ids[v]) 
	end
	table.sort(handcards, function (v1,v2) return v1:values() < v2:values() end)
	
	--五福
	local cardthree = 0
	local historyCnt = 0
	for k,v in pairs(cardMgr.history) do
		historyCnt = historyCnt + 1
		if k == R.rule.Wei or k == R.rule.Wei_chou or k == R.rule.Peng then
			cardthree = cardthree + #cardMgr.showed[k]
		end
	end
	if cardthree == 5 then
		return R.wintype.wufu
	end

	--四清跑双
	if cardthree == 4 and ruleHelp:noneSingle(handcards) then
		return R.wintype.paoshuang
	end
	
	--七对
	local cardtwo = 0
	local noneCards = cardMgr.handed[R.rule.None]
	if #noneCards >= 14 then
		local i = 1
		while i <= #noneCards-1 do
			if ids[noneCards[i]]:equal(ids[noneCards[i+1]]) then
				cardtwo = cardtwo + 1
				i = i + 2
			else
				i = i + 1
			end
		end
		
		if cardtwo >= 7 then
			return R.wintype.qidui
		end
	end
	
	--双龙
	if cardMgr.showed[R.rule.Ti_zimo] and #cardMgr.showed[R.rule.Ti_zimo] >= 2 then
		return R.wintype.shuanglong
	end
	if cardMgr.showed[R.rule.Ti_kan] and #cardMgr.showed[R.rule.Ti_kan] >= 2 then
		return R.wintype.shuanglong
	end
	if cardMgr.showed[R.rule.Ti_wei] and #cardMgr.showed[R.rule.Ti_wei] >= 2 then
		return R.wintype.shuanglong
	end
	
	
	--平胡
	if ruleHelp:noneSingle(handcards) then
		if historyCnt == 0 then
			return R.wintype.tianhu
		elseif historyCnt == 1 then
			return R.wintype.dihu
		else
			return R.wintype.pinghu
		end
	end
	
	return R.wintype.none
end

function ruleHelp:noneSingle(cards)
	local cardcnt = #cards
	if cardcnt == 0 then return true end
	if cardcnt == 1 then return false end
	if cardcnt == 2 then return cards[1]:equal(cards[2]) end
	
	if cards[1]:same(cards[2]) and cards[1]:same(cards[3]) then
		local remains = {}
		for i=4, cardcnt do table.insert(remains, cards[i]) end
		if ruleHelp:noneSingle(remains) then return true end
	end

	local remains = {}
	local kv = cards[1].value
	local begin = cards[1].value
	for i=2, cardcnt do
		if (cards[i].value - kv) == 0 then
			table.insert(remains, cards[i])
			
		elseif (cards[i].value - kv) == 1 then
			if (cards[i].value - begin) == 2 then
				local subremains = {}
				for k,v in pairs(remains) do table.insert(subremains, v) end
				for j=i+1, cardcnt do table.insert(subremains, cards[j]) end
				if ruleHelp:noneSingle(subremains) then 
					return true
				else
					table.insert(remains, cards[i])
				end
			else
				kv=kv+1
			end
		else
			break
		end
	end
	
	remains = {}
	if cards[1].value == R.value.v2 then
		local kv = R.value.v7
		for i=2, cardcnt do
			if cards[i].value == kv then
				if kv == R.value.v10 then
					local subremains = {}
					for k,v in pairs(remains) do table.insert(subremains, v) end
					for j=i+1, cardcnt do table.insert(subremains, cards[j]) end
					if ruleHelp:noneSingle(subremains) then 
						return true
					else
						table.insert(remains, cards[i])
					end
				else
					kv = R.value.v10
				end
			else
				table.insert(remains, cards[i])
			end
		end
	end
end
--[[
function ruleHelp:testHupai(handed, ids, payCard)
	local headCards = {}
	
	for k,v in pairs(handed) do
		table.insert(headCards, ids[v])
	end
	if payCard then table.insert(headCards, ids[payCard]) end
		
	table.sort(headCards, function (v1, v2)
		return v1:values() < v2:values()
	end)
	
	return ruleHelp:noneSingle(headCards)
end
--]]

--增加一张addcard牌，放到cards里面，能否产出rule的规则牌
function ruleHelp:makeRulesCard(rule, ids, cards, addcard)
	if R.rule.Chi == rule then
		return ruleMake:Chi(ids, cards, addcard)
		
	elseif R.rule.Peng == rule then
		return ruleMake:Peng(ids, cards, addcard)
		
	elseif R.rule.Wei == rule then
		return ruleMake:Peng(ids, cards, addcard)
		
	elseif R.rule.Ti == rule or R.rule.Pao == rule then
		return ruleMake:TiPao(ids, cards, addcard)

	--elseif R.rule.Hupai == rule then
		--return ruleMake:Hupai(ids, cardMgr, addcard)
		
	end
	
	return {}
end

function ruleMake:Chi_test(ids, cards)
	local tmpCards = {}
	
	if #cards ~= 3 then
		return false
	end
	
	for k,v in pairs(cards) do table.insert(tmpCards, ids[v]) end
	table.sort(tmpCards,function(v1,v2)
		return v1.value < v2.value
    end)
	
	if tmpCards[1].capital == tmpCards[2].capital and tmpCards[1].capital == tmpCards[3].capital then
		if (tmpCards[1].value+1) == tmpCards[2].value and (tmpCards[1].value+2) == tmpCards[3].value then
			return true
		elseif tmpCards[1].value == R.value.v2 and tmpCards[2].value == R.value.v7 and tmpCards[3].value == R.value.v10 then
			return true
		end
		
	elseif tmpCards[1].value == tmpCards[2].value and tmpCards[1].value == tmpCards[3].value then
		return true
	end
end

function ruleMake:Peng_test(ids, cards)
	local tmpCards = {}
	
	if #cards ~= 3 then
		return false
	end
		
	for k,v in pairs(cards) do table.insert(tmpCards, ids[v]) end
	table.sort(tmpCards,function(v1,v2)
			return v1:values() < v2:values()
		end)
	
	if tmpCards[1].value == tmpCards[2].value and tmpCards[1].value == tmpCards[3].value then
		if tmpCards[1].capital == tmpCards[2].capital and tmpCards[1].capital == tmpCards[3].capital then
			return true
		end
	end
end

function ruleMake:TiPao_test(ids, cards)
	local tmpCards = {}
	local res = {}
	
	for k,v in pairs(cards) do table.insert(tmpCards, ids[v]) end
	table.sort(tmpCards,function(v1,v2)
			return v1:values() < v2:values()
		end)
	
	
	if #cards == 4 then
		if tmpCards[1].value == tmpCards[2].value and tmpCards[1].value == tmpCards[3].value and tmpCards[1].value == tmpCards[4].value then
			if tmpCards[1].capital == tmpCards[2].capital and tmpCards[1].capital == tmpCards[3].capital and tmpCards[1].capital == tmpCards[4].capital then
				return true
			end
		end
	end
end

function ruleHelp:testRulesCard(rule, ids, cards)
	
	if R.rule.Chi == rule then
		return ruleMake:Chi_test(ids, cards)
		
	elseif R.rule.Peng == rule or R.rule.Wei == rule or R.rule.Kan == rule then
		return ruleMake:Peng_test(ids, cards)
		
	elseif R.rule.Ti == rule or R.rule.Pao == rule then
		return ruleMake:TiPao_test(ids, cards, card)

	end
	
end

function ruleHelp:isForceRule1(rule)
	return 	rule == R.rule.Ti or 
			rule == R.rule.Ti_zimo or
			rule == R.rule.Ti_kan or
			rule == R.rule.Ti_wei or
			rule == R.rule.Kan or
			rule == R.rule.Wei
end
function ruleHelp:isForceRule2(rule)
	return 	rule == R.rule.Pao or 
			rule == R.rule.Pao_kan or 
			rule == R.rule.Pao_wei or 
			rule == R.rule.Pao_peng
end

function ruleHelp:compareRuleLevel(r1, r2)
	return tonumber(r1) > tonumber(r2)
end

--是否需要显示系统发的牌
function ruleHelp:hideSystemCard(rule)
	return rule == R.rule.Ti_zimo or
			rule == R.rule.Wei or
			rule == R.rule.Wei_chou
end

function ruleHelp:checkWufuBaojing(history, hands, ids)
	local threeCnt = 0
	for k,v in pairs(history) do
		if v.payrule == R.rule.Wei or v.payrule == R.rule.Peng then
			threeCnt = threeCnt + 1
		end
	end
	
	return threeCnt == 4 and #hands == 2 and ids[hands[1]]:equal(ids[hands[2]])
end

return ruleHelp
